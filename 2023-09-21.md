# Session 01

## Summary

In this session, we accomplished:
- Creating GitHub accounts for team members
- Installing GitHub Desktop on member devices
- Installing Driver Station on member devices
- Installing WPILib on member devices
- Pulling the empty Timed Robot repo from GitHub
- Reviewing the structure of a robot program
- Creating a Joystick
- Reading the value of a button on the joystick


## Software and Accounts

If you do not already have an account, you should create one at [GitHub](https://www.github.com). Once you have an account, you can be added to the team.

If you wish to install software on your computer, these are the components installed for this session:
- [GitHub Desktop](https://desktop.github.com) (for users not already experienced with the `git` command-line tool)
- [FRC Game Tools](https://www.ni.com/en/support/downloads/drivers/download.frc-game-tools.html#479842) (Version 2023 Patch 1) - note that this is a Windows-only piece of software (Windows 10 or Windows 11)
- [WPILib](https://github.com/wpilibsuite/allwpilib/releases/tag/v2023.4.3)

The FRC Game Tools installation includes Driver Station, while the WPILib installation includes Visual Studio Code and Shuffleboard.

In addition, we reviewed two useful sources of information:
- [WPILib Documentation](https://docs.wpilib.org/en/stable/index.html). A good first-stop if you are learning more about a topic in robot programming or control systems.
- [Chief Delphi](https://www.chiefdelphi.com). **The** primary community forum for FRC teams. Great for finding answers to specific questions.


## Starter Project

You are able to use the WPILib Visual Studio Code application to generate new projects. We also have an empty starter project for a Timed Robot on the `frc538` GitHub. It can be found at [https://github.com/frc538/empty-timed-robot](https://github.com/frc538/empty-timed-robot), or you can pull it from GitHub Desktop with `frc538/empty-timed-robot`.

When you save the project, pay attention to where it is saved so you can open it in the WPILib-provided Visual Studio Code. When opening the project in Visual Studio Code, make sure to select the `empty-timed-robot` folder and click the `Select Folder` button.

While there are many files and folders in an FRC robot project, the file we will spend the most time looking at is `Robot.java`. You can find this file in the `empty-timed-robot/src/main/java/frc/robot` folder. The same structure holds for other FRC robot projects.


## Robot Program Structure

There are a few parts of the `Robot.java` file we covered. 

The `package` line at the top the file indicates where in the folder structure the file can be found. In this case, the file is in the `frc/robot` directory.
```java
package frc.robot;
```

Lines starting with `import` are used to reference code that exists in places other than the file you have open. In this case, the file references the `TimedRobot` code from WPILib.
```java
import edu.wpi.first.wpilibj.TimedRobot;
```

Lines that start with two-forward slashes (`//`) are comments - which means they are not executed code. Rather, they are notes to/from the person who wrote the code. Examples include:
```java
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.
```

Other comments are marked by starting with a single forward slash and an asterisk (`/*`) and ending with an asterisk and a single forward slash (`*/`). These are multiline comments. Examples include:
```java
/** This function is called once when autonomous is enabled. */
```

The bulk of the code in the file is in a `class`, specifically the class named `Robot`. The `class` consists of everything between the opening and closing lines, contained in a set of curly braces (`{}`):
```java
public class Robot extends TimedRobot {
    ...
}
```

Within the `Robot`, there can be things that make up the `Robot` (things that it **has**) as well as actions it can perform (things that it **does**). We refer to the things that it **does** as *methods* or *functions*.

The `Robot` has two kinds of *methods*: `init` methods and `periodic` methods. An `init` method runs exactly one time when the robot begins to change its behavior. For example, at the start of the teleop part of a match, there is an `init` method that will run one time so the robot can get ready for teleop. Every `init` has a corresponding `periodic` that runs many times (about once every 20 milliseconds) while the robot is in that behavior.

The `init` methods include:
```java
@Override
public void robotInit() {}

@Override
public void autonomousInit() {}

@Override
public void teleopInit() {}

@Override
public void disabledInit() {}

@Override
public void testInit() {}

@Override
public void simulationInit() {}
```

The `periodic` methods include:
```java
@Override
public void robotPeriodic() {}

@Override
public void autonomousPeriodic() {}

@Override
public void teleopPeriodic() {}

@Override
public void disabledPeriodic() {}

@Override
public void testPeriodic() {}

@Override
public void simulationPeriodic() {}
```

When the teleop part of match happens, the robot runs `teleopInit` to get ready for teleop, exactly one time, and then it runs `teleopPeriodic` one time every 20 ms (or so) as long as teleop is still happening. Because of this behavior, you should almost never write loops in your robot code, because the `periodic` methods act like loops themselves.

The different phases the robot can go through are:
- `autonomous` - During the autonomous portion of the match
- `teleop` - During the teleop portion of the match
- `test` - When running in Test mode from Driver Station
- `disabled` - When the robot affirmitively disabled through Driver Station, transitioning between other stages, or just passively powered on.

The `simulation` methods are only run when the robot code is being run in simulation mode.

The `robotInit` method runs when the robot is first turned on, and the `robotPeriodic` method will run every 20 ms (or so) while the robot is powered on. These functions will execute **in addition to** any other phase-specific methods (like `teleop` or `autonomous`).

The actions that happen when a method runs are defined in the set of curly braces (`{}`) for that method. For example, this method as nothing between its braces, so nothing happens:
```java
@Override
public void robotPeriodic() {}
```

The same is true for this method, since there are only blank lines between the braces:
```java
@Override
public void robotPeriodic() {

}
```

Actions can include:
- moving a motor
- firing a solenoid
- reading a sensor
- reporting data

along with many other things. Actions involving the motion of **actuators** (like motors) can only occur during certain phases. For example, motors **will not work** while the robot is disabled. Since the `robotPeriodic` method runs all of the time, you should only put code in that method that deals with reading/writing data (*e.g.*, reporting sensor values).


## Creating a Joystick

One of the key components of a robot, even without a physical robot, is something you can use to control the robot. Any device that can connect to your computer that runs Driver Station via a USB connection (more or less) can be considered a `Joystick`, the most common being flight-sticks and gamepads.

Since the `Robot` `class` includes things the robot **has** and **can do**, a `Joystick` can be added to the robot as something it *has*.

You can add a `Joystick`, or other things, to the `class` by going to the first blank line *inside* the `class` (that is, after the opening brace (`{`) of the `class`).

```java
public class Robot extends TimedRobot {
    // Things the robot has can go here
...
}
```

To tell the robot that it will have a `Joystick`, we are going to use a **variable**. In programming, think of a variable like a box. It is some place in the memory of whatever runs your code. This box has two key features:
- A shape/size (called the variable's `type`) and
- A name

Different kinds of data and things fit inside boxes of different shapes and sizes, and, in most cases, you can't put things in boxes that are the wrong shape - they must fit *exactly* (though there are exceptions). This shape/size of the variable is called its `type`.

Variables also have names so that you can easily find and use them later. For example, we might have two or three `Joystick`s on a robot, and giving them different names makes it easy to know which one we're using.

When you create a variable, you'll write the `type` followed by the name, like:
```java
Type name;
```

The semicolon (`;`) at the end of the line is a piece of punctuation like a period. It essentially means that you have written a complete thought and tells the program that whatever comes after it is the next thought or instruction. The line in the example above, in English, reads: "I want to set aside an empty box that can hold something that is a `Type`, and I want to call that box `name`."

In the case of a `Joystick`, the type is called `Joystick`, and we will name it something simple like `testJoystick`. The problem, though, is that our program doesn't know what a `Joystick` is - that is something that WPILib has definied for us.

When you start typing out the name of the type you want, pay attention to the hints that Visual Studio Code produces. If you see what you need in the list, selecting it (instead of typing it out the first time), will automatically add an `import` line to your program so you can use it. For example:

<img src="https://i.imgur.com/MNcltOP.png" width=700px/>

Clicking on the `Joystick` option will finish the word `Joystick` and add a line at the top of your program:
```java
package frc.robot;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.TimedRobot;

...

public class Robot extends TimedRobot {
  Joystick
  ...
}
```

Finishing the line, we have:
```java
public class Robot extends TimedRobot {
  Joystick testJoystick;
  ...
}
```

At this point, we have given the robot somewhere to hold (or store) a `Joystick`, but we haven't *made* a `Joystick` yet. We have a variable to *hold* a `Joystick`, but we need to create (or *instantiate*) a `Joystick`.

Since the robot will need this `Joystick` as soon as it powers on, we will create the `Joystick` in `robotInit`:
```java
@Override
public void robotInit() {}
```

To add actions (*i.e.*, code) into the `robotInit` method, we need to add lines between the curly braces (`{}`):
```java
@Override
public void robotInit() {

}
```

Since we gave the variable the name `testJoystick`, we will use that to refer to it. We use the equals sign (`=`) called the *assignment operator* to give it a value.
```java
@Override
public void robotInit() {
    testJoystick =
}
```

Note that a single equals sign does not mean "is the same as." Rather, it means "I want to put the thing on the right inside the variable on the left," or "the variable on the left GETS the thing on the right."

Whenever we *create* something in Java, like a `Joystick`, we use the word `new`.

```java
@Override
public void robotInit() {
    testJoystick = new
}
```

To make a `Joystick`, we use a special piece of code called a *constructor*. This is the name of the type (in this case, `Joystick`) with a set of parentheses (`()`), along with any information required between the parentheses. In the case of `Joystick`, we have to supply a `port` number that matches the number of the port displayed in Driver Station. Since the first port is `0`, we will use that value. Since this line is a complete thought ("go to the variable named `testJoystick` and give it a new `Joystick` at Driver Station port `0`"), we end the line with a semicolon.

```java
@Override
public void robotInit() {
    testJoystick = new Joystick(0);
}
```

Visual Studio Code will show the names of parameters in methods, like the constructor. In this case, the `Joystick` constructor takes one parameter named `port`, so Visual Studio Code will display that for you - even though you **do not** type out the word "port" in the code. If you actually type out "port:" as part of the code, you'll produce errors.

<img src="https://i.imgur.com/KQ22D08.png" width=700px/>

At this point, your robot has a single `Joystick` that can now be used.


## Reading a Button

