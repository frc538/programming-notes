# Session 01

## Summary

In this session, we accomplished:
- Creating GitHub accounts for team members
- Installing GitHub Desktop on member devices
- Installing Driver Station on member devices
- Installing WPILib on member devices
- Pulling the empty Timed Robot repo from GitHub
- Reviewing the structure of a robot program
- Creating a Joystick
- Reading the value of a button on the joystick


## Software and Accounts

If you do not already have an account, you should create one at [GitHub](https://www.github.com). Once you have an account, you can be added to the team.

If you wish to install software on your computer, these are the components installed for this session:
- [GitHub Desktop](https://desktop.github.com) (for users not already experienced with the `git` command-line tool)
- [FRC Game Tools](https://www.ni.com/en/support/downloads/drivers/download.frc-game-tools.html#479842) (Version 2023 Patch 1) - note that this is a Windows-only piece of software (Windows 10 or Windows 11)
- [WPILib](https://github.com/wpilibsuite/allwpilib/releases/tag/v2023.4.3)

The FRC Game Tools installation includes Driver Station, while the WPILib installation includes Visual Studio Code and Shuffleboard.

In addition, we reviewed two useful sources of information:
- [WPILib Documentation](https://docs.wpilib.org/en/stable/index.html). A good first-stop if you are learning more about a topic in robot programming or control systems.
- [Chief Delphi](https://www.chiefdelphi.com). **The** primary community forum for FRC teams. Great for finding answers to specific questions.


## Starter Project

You are able to use the WPILib Visual Studio Code application to generate new projects. We also have an empty starter project for a Timed Robot on the `frc538` GitHub. It can be found at [https://github.com/frc538/empty-timed-robot](https://github.com/frc538/empty-timed-robot), or you can pull it from GitHub Desktop with `frc538/empty-timed-robot`.

When you save the project, pay attention to where it is saved so you can open it in the WPILib-provided Visual Studio Code. When opening the project in Visual Studio Code, make sure to select the `empty-timed-robot` folder and click the `Select Folder` button.

While there are many files and folders in an FRC robot project, the file we will spend the most time looking at is `Robot.java`. You can find this file in the `empty-timed-robot/src/main/java/frc/robot` folder. The same structure holds for other FRC robot projects.


## Robot Program Structure

There are a few parts of the `Robot.java` file we covered. 

The `package` line at the top the file indicates where in the folder structure the file can be found. In this case, the file is in the `frc/robot` directory.
```java
package frc.robot;
```

Lines starting with `import` are used to reference code that exists in places other than the file you have open. In this case, the file references the `TimedRobot` code from WPILib.
```java
import edu.wpi.first.wpilibj.TimedRobot;
```

Lines that start with two-forward slashes (`//`) are comments - which means they are not executed code. Rather, they are notes to/from the person who wrote the code. Examples include:
```java
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.
```

Other comments are marked by starting with a single forward slash and an asterisk (`/*`) and ending with an asterisk and a single forward slash (`*/`). These are multiline comments. Examples include:
```java
/** This function is called once when autonomous is enabled. */
```

The bulk of the code in the file is in a `class`, specifically the class named `Robot`. The `class` consists of everything between the opening and closing lines, contained in a set of curly braces (`{}`):
```java
public class Robot extends TimedRobot {
    ...
}
```

Within the `Robot`, there can be things that make up the `Robot` (things that it **has**) as well as actions it can perform (things that it **does**). We refer to the things that it **does** as *methods* or *functions*.

The `Robot` has two kinds of *methods*: `init` methods and `periodic` methods. An `init` method runs exactly one time when the robot begins to change its behavior. For example, at the start of the teleop part of a match, there is an `init` method that will run one time so the robot can get ready for teleop. Every `init` has a corresponding `periodic` that runs many times (about once every 20 milliseconds) while the robot is in that behavior.

The `init` methods include:
```java
@Override
public void robotInit() {}

@Override
public void autonomousInit() {}

@Override
public void teleopInit() {}

@Override
public void disabledInit() {}

@Override
public void testInit() {}

@Override
public void simulationInit() {}
```

The `periodic` methods include:
```java
@Override
public void robotPeriodic() {}

@Override
public void autonomousPeriodic() {}

@Override
public void teleopPeriodic() {}

@Override
public void disabledPeriodic() {}

@Override
public void testPeriodic() {}

@Override
public void simulationPeriodic() {}
```

When the teleop part of match happens, the robot runs `teleopInit` to get ready for teleop, exactly one time, and then it runs `teleopPeriodic` one time every 20 ms (or so) as long as teleop is still happening. Because of this behavior, you should almost never write loops in your robot code, because the `periodic` methods act like loops themselves.

The different phases the robot can go through are:
- `autonomous` - During the autonomous portion of the match
- `teleop` - During the teleop portion of the match
- `test` - When running in Test mode from Driver Station
- `disabled` - When the robot affirmitively disabled through Driver Station, transitioning between other stages, or just passively powered on.

The `simulation` methods are only run when the robot code is being run in simulation mode.

The `robotInit` method runs when the robot is first turned on, and the `robotPeriodic` method will run every 20 ms (or so) while the robot is powered on. These functions will execute **in addition to** any other phase-specific methods (like `teleop` or `autonomous`).

The actions that happen when a method runs are defined in the set of curly braces (`{}`) for that method. For example, this method as nothing between its braces, so nothing happens:
```java
@Override
public void robotPeriodic() {}
```

The same is true for this method, since there are only blank lines between the braces:
```java
@Override
public void robotPeriodic() {

}
```

Actions can include:
- moving a motor
- firing a solenoid
- reading a sensor
- reporting data

along with many other things. Actions involving the motion of **actuators** (like motors) can only occur during certain phases. For example, motors **will not work** while the robot is disabled. Since the `robotPeriodic` method runs all of the time, you should only put code in that method that deals with reading/writing data (*e.g.*, reporting sensor values).


## Creating a Joystick


## Reading a Button